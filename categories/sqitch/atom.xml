<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sqitch | theory.so]]></title>
  <link href="http://theory.so/categories/sqitch/atom.xml" rel="self"/>
  <link href="http://theory.so/"/>
  <updated>2014-01-13T16:33:41-08:00</updated>
  <id>http://theory.so/</id>
  <author>
    <name><![CDATA[David E. Wheeler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
    <entry>
      




<title type="html"><![CDATA[Templating Tests with Sqitch]]></title>
<link href="http://theory.so/sqitch/2014/01/13/templating-tests-with-sqitch/"/>
<updated>2014-01-13T14:11:00-08:00</updated>
<id>http://theory.so/sqitch/2014/01/13/templating-tests-with-sqitch</id>

      <content type="html"><![CDATA[<p>Back in September, <a href="/sqitch/2013/09/06/sqitch-templating/">I described</a> how to create custom deploy, revert, and
verify scripts for various types of <a href="http://sqitch.org/" title="Sane database schema change management">Sqitch</a> changes, such as adding a new
table. Which is cool and all, but what I&rsquo;ve found while developing databases
at <a href="http://iovation.com/">work</a> is that I nearly always want to create a test script with the same
name as a newly-added change.</p>

<p>So for the recent v0.990 release, the <a href="https://metacpan.org/pod/sqitch-add"><code>add</code> command</a> gained the ability to
generate arbitrary script files from templates. To get it to work, we just
have to create template files. Templates can go into <code>~/.sqitch/templates</code>
(for personal use) or in <code>$(sqitch --etc-path)/templates</code> (for use by
everyone on a system). The latter is where templates are installed by
default. Here&rsquo;s what it looks like:</p>

<pre><code class="sh List Default Templates">&gt; ls $(sqitch --etc-path)/templates
deploy  revert  verify
&gt; ls $(sqitch --etc-path)/templates/deploy
firebird.tmpl  mysql.tmpl  oracle.tmpl  pg.tmpl  sqlite.tmpl
</code></pre>

<p>Each directory defines the type of script and the name of the directory in
which it will be created. The contents are default templates, one for each
engine.</p>

<p>To create a default test template, all we have to do is create a template for our preferred engine in a directory named <code>test</code>. So I created <code>~/.sqitch/templates/test/pg.tmpl</code>. Here it is:</p>

<pre><code class="sql Default pgTAP template">SET client_min_messages TO warning;
CREATE EXTENSION IF NOT EXISTS pgtap;
RESET client_min_messages;

BEGIN;
SELECT no_plan();
-- SELECT plan(1);

SELECT pass('Test [% change %]!');

SELECT finish();
ROLLBACK;
</code></pre>

<p>This is my standard boilerplate for tests, more or less. It just loads
<a href="http://pgtap.org/">pgTAP</a>, sets the plan, runs the tests, finishes and rolls back. See this
template in action:</p>

<pre><code class="sh Add a change.">&gt; sqitch add whatever -n 'Adds whatever.'
Created deploy/whatever.sql
Created revert/whatever.sql
Created test/whatever.sql
Created verify/whatever.sql
Added "whatever" to sqitch.plan
</code></pre>

<p>Cool, it added the test script. Hereâ€™s what it looks like:</p>

<pre><code class="sql Generated test script">SET client_min_messages TO warning;
CREATE EXTENSION IF NOT EXISTS pgtap;
RESET client_min_messages;

BEGIN;
SELECT no_plan();
-- SELECT plan(1);

SELECT pass('Test whatever!');

SELECT finish();
ROLLBACK;
</code></pre>

<p>Note that it replaced the <code>change</code> variable in the call to <code>pass()</code>. All
ready to start writing tests! Nice, right? If we don&rsquo;t want the test script
created &ndash; for example when adding a column to a table for which a test
already exists &ndash; we use the <code>--without</code> option to omit it:</p>

<pre><code class="sh Add change without test">&gt; sqitch add add_timestamp_column --without test -n 'Adds whatever.'
Created deploy/add_timestamp_column.sql
Created revert/add_timestamp_column.sql
Created verify/add_timestamp_column.sql
Added "add_timestamp_column" to sqitch.plan
</code></pre>

<p>Naturally you&rsquo;ll want to update the existing test to validate the new column.</p>

<p>In the <a href="/sqitch/2013/09/06/sqitch-templating/">previous templating post</a>, we added custom scripts as for <code>CREATE
TABLE</code> changes; now we can add a test template, too. This one takes advantage
of the advanced features of <a href="http://tt2.org/">Template Toolkit</a>. We name it
<code>~/.sqitch/templates/test/createtable.tmpl</code> to complement the deploy,
revert, and verify scripts created previously:</p>

<pre><code class="sql CREATE TABLE test template">-- Test [% change %]
SET client_min_messages TO warning;
CREATE EXTENSION IF NOT EXISTS pgtap;
RESET client_min_messages;

BEGIN;
SELECT no_plan();
-- SELECT plan(1);

SET search_path TO [% IF schema %][% schema %],[% END %]public;

SELECT has_table('[% table or change %]');
SELECT has_pk( '[% table or change %]' );

[% FOREACH col IN column -%]
SELECT has_column(        '[% table or change %]', '[% col %]' );
SELECT col_type_is(       '[% table or change %]', '[% col %]', '[% type.item( loop.index ) or 'text' %]' );
SELECT col_not_null(      '[% table or change %]', '[% col %]' );
SELECT col_hasnt_default( '[% table or change %]', '[% col %]' );

[% END %]
SELECT finish();
ROLLBACK;
</code></pre>

<p>As <a href="/sqitch/2013/09/06/sqitch-templating/">before</a>, we tell the <a href="https://metacpan.org/pod/sqitch-add"><code>add</code> command</a> to use the <code>createtable</code> templates:</p>

<pre><code class="sh Create table with typed columns">&gt; sqitch add corp_widgets --template createtable \
  -s schema=corp -s table=widgets \
  -s column=id -s type=SERIAL \
  -s column=name -s type=TEXT \
  -s column=quantity -s type=INTEGER \
  -n 'Add corp.widgets table.'
</code></pre>

<p>This yields a very nice test script to get you going:</p>

<pre><code class="sql Generated Table Test">-- Test corp_widgets
SET client_min_messages TO warning;
CREATE EXTENSION IF NOT EXISTS pgtap;
RESET client_min_messages;

BEGIN;
SELECT no_plan();
-- SELECT plan(1);

SET search_path TO corp,public;

SELECT has_table('widgets');
SELECT has_pk( 'widgets' );

SELECT has_column(        'widgets', 'id' );
SELECT col_type_is(       'widgets', 'id', 'SERIAL' );
SELECT col_not_null(      'widgets', 'id' );
SELECT col_hasnt_default( 'widgets', 'id' );

SELECT has_column(        'widgets', 'name' );
SELECT col_type_is(       'widgets', 'name', 'TEXT' );
SELECT col_not_null(      'widgets', 'name' );
SELECT col_hasnt_default( 'widgets', 'name' );

SELECT has_column(        'widgets', 'quantity' );
SELECT col_type_is(       'widgets', 'quantity', 'INTEGER' );
SELECT col_not_null(      'widgets', 'quantity' );
SELECT col_hasnt_default( 'widgets', 'quantity' );


SELECT finish();
ROLLBACK;
</code></pre>

<p>I don&rsquo;t know about you, but I&rsquo;ll be using this functionality <em>a lot.</em></p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Sqitch on Target]]></title>
<link href="http://theory.so/sqitch/2014/01/09/sqitch-on-target/"/>
<updated>2014-01-09T15:27:00-08:00</updated>
<id>http://theory.so/sqitch/2014/01/09/sqitch-on-target</id>

      <content type="html"><![CDATA[<p>At the end of the day last week, I released <a href="http://sqitch.org/">Sqitch</a> v0.990. This was a
pretty big release, with lots of changes. The most awesome addition, in my
opinion, is <em>Named Deployment targets.</em></p>

<p>In previous versions of Sqitch, one
could set default values for the database to deploy to, but needed to use the
<code>--db-*</code> options to deploy to another database. This was fine for
development: just set the default on <code>localhost</code> and go. But when it came
time to deploy to other servers for testing, QA, or production, it was a bit
of a PITA. At <a href="http://www.iovation.com/">work</a>, I ended up writing deployment docs that defined a slew
of environment variables, and our operations team needed to adjust those
variables to deploy to various servers. It was ugly, and frankly a bit of a
pain in the ass.</p>

<p>I thought it&rsquo;d be better to have named deployment targets, so instead of
changing a bunch of environment variables in order to set a bunch of options,
we could just name a target and go. I borrowed the idea from <a href="http://git-scm.com/docs/git-remote">Git remotes</a>,
and started a <a href="https://github.com/theory/uri-db">database URI spec</a> (mentioned <a href="/rfc/2013/11/26/toward-a-database-uri-standard/">previously</a>) to simplify things
a bit. Here&rsquo;s how it works. Say you have a PostgreSQL Sqitch project called
&ldquo;Flipr&rdquo;. While doing development, you&rsquo;ll want to have a local database to
deploy to. There is also a QA database and a production database. Use the
<a href="https://metacpan.org/pod/sqitch-target"><code>target</code></a> command to set them up:</p>

<pre><code class="sh Sqitch Targeting">sqitch target add dev db:pg:flipr
sqitch target add qa db:pg://sqitch@qa.example.com/flipr
sqitch target add prod db:pg://sqitch@db.example.com/flipr
</code></pre>

<p>Like <a href="http://git-scm.com/docs/git-remote">Git remotes</a>, we just have names and URIs. To <a href="https://metacpan.org/pod/sqitch-deploy"><code>deploy</code></a> to a database,
just name it:</p>

<pre><code class="sh Deploy to Dev">sqitch deploy dev
</code></pre>

<p>Want to deploy to QA? Name it:</p>

<pre><code class="sh Deploy to QA">sqitch deploy qa
</code></pre>

<p>This works with any of the commands that connect to a database, including
<a href="https://metacpan.org/pod/sqitch-revert"><code>revert</code></a> and <a href="https://metacpan.org/pod/sqitch-status"><code>status</code></a>:</p>

<pre><code class="sh Targeted revert, Status">sqitch revert --to @HEAD^^ dev
sqitch status prod
</code></pre>

<p>The great thing about this feature is that the configuration is all stored
in the project Sqitch configuration file. That means you can commit all the
connection URIs for all likely targets in directly to the project repository.
If they change, just change them in the config, commit, and push.</p>

<p>Targets don&rsquo;t always have to be configured in advance, of course. The names
essentially stand in for the URIs, so you can connect to an unnamed target
just by using a URI:</p>

<pre><code class="sh URI Targeting">sqitch log db:postgres://db1.example.net/flipr_export
</code></pre>

<p>Of course there are still defaults specific to each engine. I generally like
to set the &ldquo;dev&rdquo; target as the default deploy target, like so:</p>

<pre><code class="sh Configure Default Target">sqitch config core.pg.target dev
</code></pre>

<p>This sets the &ldquo;dev&rdquo; target as the default for the PostgreSQL engine. So now I
can do stuff with the &ldquo;dev&rdquo; target without mentioning it at all:</p>

<pre><code class="sh Rebase Dev Target">sqitch rebase --onto HEAD^4
</code></pre>

<p>Named targets may also have a couple other attributes associated with them:</p>

<ul>
<li><code>client</code>: The command-line client to use for a target.</li>
<li><code>registry</code>: The name of the Sqitch registry schema or database, which defaults to, simply, <code>sqitch</code>.</li>
</ul>


<p>Now that I&rsquo;ve started using it, I can think of other things I&rsquo;d like to add to targets in the future, including:</p>

<ul>
<li><a href="https://github.com/theory/sqitch/issues/143">Setting other attributes</a>, such as the deployment mode, whether to verify changes, and variables.</li>
<li><a href="https://github.com/theory/sqitch/issues/135">Allowing multiple URIs</a>, for concurrent database deployments!</li>
</ul>


<p>Pretty cool stuff ahead, IMO. I&rsquo;m grateful to <a href="http://www.iovation.com/">work</a> for letting me hack on
Sqitch.</p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Sqitch Templating]]></title>
<link href="http://theory.so/sqitch/2013/09/06/sqitch-templating/"/>
<updated>2013-09-06T13:44:00-07:00</updated>
<id>http://theory.so/sqitch/2013/09/06/sqitch-templating</id>

      <content type="html"><![CDATA[<p>Last week saw the v.980 release of <a href="http://sqitch.org/" title="Sane database change management">Sqitch</a>, a database change management
system. The headline feature in this version is support for <a href="http://dev.mysql.com/" title="The world's most popular open source database">MySQL</a> 5.6.4 or
higher. Why 5.6.4 rather than 5.1 or even 5.5? Mainly because 5.6.4 finally
added support for fractional seconds in <code>DATETIME</code> columns (details in the
<a href="https://dev.mysql.com/doc/relnotes/mysql/5.6/en/news-5-6-4.html" title="Changes in MySQL 5.6.4 (2011-12-20, Milestone 7)">release notes</a>). This feature is essential for Sqitch, because changes often
execute within a second of each other, and the deploy time is included in the
log table&rsquo;s primary key.</p>

<p>With the requirement for fractional seconds satisfied by 5.6.4, there was
nothing to prevent usage of <a href="http://dev.mysql.com/doc/refman/5.5/en/condition-handling.html" title="MySQL 5.5 Reference Manual: Condition Handling"><code>SIGNAL</code></a>, added in 5.5, to
<a href="http://stackoverflow.com/a/17424570/79202" title="How do I get MySQL to throw a conditional runtime exception in SQL">mimic check constraints</a> in a trigger. This brings the Sqitch MySQL
implementation into line with what was already possible in the Postgres,
SQLite, and Oracle support. Check out the <a href="https://metacpan.org/module/sqitchtutorial-mysql" title="A tutorial introduction to Sqitch change management on MySQL">tutorial</a> and the accompanying
<a href="https://github.com/theory/sqitch-mysql-intro" title="Sqitch MySQL Intro Sample Repository">Git repository</a> to get started managing your MySQL databases with Sqitch.</p>

<p>The MySQL support might be the headliner, but the change in v0.980 I&rsquo;m most
excited about is improved template support. Sqitch executes templates to
create the default deploy, revert, and verify scripts, but up to now they have
not been easy to customize. With v0.980, you can create as many custom
templates as you like, and use them as appropriate.</p>

<!-- more -->


<h2>A Custom Template</h2>

<p>Let&rsquo;s create a custom template for creating a table. The first step is to
create the template files. Custom templates can live in <code>`sqitch
&ndash;etc-path`/templates</code> or in <code>~/.sqitch/templates</code>. Let&rsquo;s use the
latter. Each template goes into a directory for the type of script, so we&rsquo;ll
create them:</p>

<pre><code class="sh Create template directories">mkdir -p ~/.sqitch/templates/deploy
mkdir -p ~/.sqitch/templates/revert 
mkdir -p ~/.sqitch/templates/verify
</code></pre>

<p>Copy the default templates for your preferred database engine; here I copy the
Postgres templates:</p>

<pre><code class="sh Copy default templates">tmpldir=`sqitch --etc-path`/templates
cp $tmpldir/deploy/pg.tmpl ~/.sqitch/templates/deploy/createtable.tmpl
cp $tmpldir/revert/pg.tmpl ~/.sqitch/templates/revert/createtable.tmpl
cp $tmpldir/verify/pg.tmpl ~/.sqitch/templates/verify/createtable.tmpl
chmod -R +w ~/.sqitch/templates
</code></pre>

<p>Here&rsquo;s what the default deploy template looks like:</p>

<pre><code class="sql Default deploy template">-- Deploy [% change %]
[% FOREACH item IN requires -%]
-- requires: [% item %]
[% END -%]
[% FOREACH item IN conflicts -%]
-- conflicts: [% item %]
[% END -%]

BEGIN;

-- XXX Add DDLs here.

COMMIT;
</code></pre>

<p>The code before the <code>BEGIN</code> names the template and lists dependencies, which
is reasonably useful, so we&rsquo;ll leave it as-is. We&rsquo;ll focus on replacing that
comment, <code>-- XXX Add DDLs here.</code>, with the template for a <code>CREATE TABLE</code>
statement. Start simple: just use the change name for the table name. In
<code>~/.sqitch/templates/deploy/createtable.tmpl</code>, replace the comment with these
lines:</p>

<pre><code class="sql Add CREATE TABLE statement to deploy template">CREATE TABLE [% change %] (
    -- Add columns here.
);
</code></pre>

<p>In the revert template, <code>~/.sqitch/templates/deploy/createtable.tmpl</code>, replace
the comment with a <code>DROP TABLE</code> statement:</p>

<pre><code class="sql Add DROP TABLE statement to revert template">DROP TABLE [% change %];
</code></pre>

<p>And finally, in the verify template,
<code>~/.sqitch/templates/verify/createtable.tmpl</code>, replace the comment with a
simple <code>SELECT</code> statement, which is just enough to verify the creation of a
table:</p>

<pre><code class="sql Add SELECT statement to verify template">SELECT * FROM [% change %];
</code></pre>

<p>Great, we&rsquo;ve created a set of simple customized templates for adding a
<code>CREATE TABLE</code> change to a Sqitch project. To use them, just pass the
<code>--template</code> option to <a href="http://metacpan.org/module/sqitch-add" title="Add a database change to the Sqitch plan"><code>sqitch add</code></a>, like so:</p>

<pre><code class="sh Use the createtable template">&gt; sqitch add widgets --template createtable -n 'Add widgets table.'
Created deploy/widgets.sql
Created revert/widgets.sql
Created verify/widgets.sql
Added "widgets" to sqitch.plan
</code></pre>

<p>Now have a look at <code>deploy/widgets.sql</code>:</p>

<pre><code class="sql Widgets Deploy Script">-- Deploy widgets

BEGIN;

CREATE TABLE widgets (
    -- Add columns here.
);

COMMIT;
</code></pre>

<p>Cool! The revert template should also have done its job. Here&rsquo;s
<code>revert/widgets.sql</code>:</p>

<pre><code class="sql Widgets Revert Script">-- Revert widgets

BEGIN;

DROP TABLE widgets;

COMMIT;
</code></pre>

<p>And the verify script, <code>verify/widgets.sql</code>:</p>

<pre><code class="sql Widgets Verify Script">-- Verify widgets

BEGIN;

SELECT * FROM widgets;

ROLLBACK;
</code></pre>

<h2>Custom Table Name</h2>

<p>What if you want to name the change one thing and the table it creates
something else? What if you want to schema-qualify the table? Easy! Sqitch&rsquo;s
dead simple default <a href="https://metacpan.org/module/sqitch-add#Syntax" title="Sqitch Template Syntax">templating language</a>, <a href="https://metacpan.org/module/Template::Tiny">Template::Tiny</a>, features <code>if</code>
statements. Try using them with custom variables for the schema and table
names:</p>

<pre><code class="sql Deploy table with schema and table">SET search_path TO [% IF schema ][% schema %],[% END %]public;

CREATE TABLE [% IF table %][% table %][% ELSE %][% change %][% END %] (
    -- Add columns here.
);
</code></pre>

<p>If the <code>schema</code> variable is set, the <code>search_path</code>, which determines where
objects will go, gets set to <code>$schema,public</code>. If <code>schema</code> is not set, the
path is simply <code>public</code>, which is the default schema in Postgres.</p>

<p>We take a similar tack with the <code>CREATE TABLE</code> statement: If the <code>table</code>
variable is set, it&rsquo;s used as the name of the table. Otherwise, we use the
change name, as before.</p>

<p>The revert script needs the same treatment:</p>

<pre><code class="sql Revert table with schema and table">SET search_path TO [% IF schema ][% schema %],[% END %]public;
DROP TABLE [% IF table %][% table %][% ELSE %][% change %][% END %];
</code></pre>

<p>As does the verify script:</p>

<pre><code class="sql Verify table with schema and table">SET search_path TO [% IF schema ][% schema %],[% END %]public;
SELECT * FROM [% IF table %][% table %][% ELSE %][% change %][% END %];
</code></pre>

<p>Take it for a spin:</p>

<pre><code class="sh Add table to schema">&gt; sqitch add corp_widgets --template createtable \
  --set schema=corp --set table=widgets \
  -n 'Add corp.widgets table.'
Created deploy/corp_widgets.sql
Created revert/corp_widgets.sql
Created verify/corp_widgets.sql
Added "corp_widgets" to sqitch.plan
</code></pre>

<p>The resulting deploy script will create <code>corp.widgets</code>:</p>

<pre><code class="sql Deploy table to schema">-- Deploy corp_widgets

BEGIN;

SET search_path TO corp,public;

CREATE TABLE widgets (
    -- Add columns here.
);

COMMIT;
</code></pre>

<p>Cool, right? The revert and verify scripts of course yield similar results.
Omitting the <code>--set</code> option, the template falls back on the change name:</p>

<pre><code class="sql Deploy a table to public">-- Deploy widgets

BEGIN;

SET search_path TO public;

CREATE TABLE widgets (
    -- Add columns here.
);

COMMIT;
</code></pre>

<h2>Add Columns</h2>

<p>Template variables may contain array values. The default templates takes
advantage of this feature to list dependencies in SQL comments. It works great
for custom variables, too. For the purposes of our <code>CREATE TABLE</code> template,
let&rsquo;s add columns. Replace the <code>-- Add columns here</code> comment in the deploy
simple with these three lines:</p>

<pre><code class="sql Deploy script with columns">[% FOREACH col IN column -%]
    [% col %] TEXT NOT NULL,
[% END -%]
</code></pre>

<p>We can similarly improve the verify script: change its <code>SELECT</code> statement to:</p>

<pre><code class="sql Verify script with columns">SELECT [% FOREACH col IN column %][% col %], [% END %]
  FROM [% IF table %][% table %][% ELSE %][% change %][% END %];
</code></pre>

<p>Just pass multiple <code>--set</code> (or <code>-s</code>) options to <code>sqitch add</code> to add as many
columns as you like:</p>

<pre><code class="sh Add table with columns">&gt; sqitch add corp_widgets --template createtable \
  -s schema=corp -s table=widgets \
  -s column=id -s column=name -s column=quantity \
  -n 'Add corp.widgets table.'
</code></pre>

<p>Behold the resulting deploy script!</p>

<pre><code class="sql Deploy table with columns">-- Deploy corp_widgets

BEGIN;

SET search_path TO corp,public;

CREATE TABLE widgets (
    id TEXT NOT NULL,
    name TEXT NOT NULL,
    quantity TEXT NOT NULL,
);

COMMIT;
</code></pre>

<p>You still have to edit the resulting file, of course. Maybe <code>NULL</code>s should be
allowed in the <code>name</code> column. And I suspect that <code>quantity</code> ought be an
integer. There&rsquo;s that pesky trailing comma to remove, too. The verify script
suffers the same deficiency:</p>

<pre><code class="sql Verify each column">-- Verify corp_widgets

BEGIN;

SET search_path TO corp,public;
SELECT id, name, quantity, 
  FROM widgets;

ROLLBACK;
</code></pre>

<p>Still, these templates remove much of the grudge work of adding <code>CREATE TABLE</code>
changes, giving you the scaffolding on which to build the objects you need.</p>

<h2>Upgraded Templates</h2>

<p>We call Sqitch&rsquo;s <a href="https://metacpan.org/module/sqitch-add#Syntax" title="Sqitch Template Syntax">templating language</a> &ldquo;default&rdquo; because it can be replaced
with a more capable one. Simply install <a href="http://tt2.org/">Template Toolkit</a> to transparently
upgrade your Sqitch templates. Template Toolkit&rsquo;s comprehensive feature set
covers just about any functionality you could want out of a templating system.
It&rsquo;s big and complex, but relatively straight-forward to install: just run
<code>cpan Template</code>, <code>cpanm Template</code>, <code>yum install perl-Template-Toolkit</code>, or the
like and you&rsquo;ll be in business.</p>

<p>We can resolve the trailing comma issue thanks to Template Toolkit&rsquo;s <code>loop</code>
variable, which is implicitly created in the <code>FOREACH</code> loop. Simply replace
the comma in the template with the expression <code>[% loop.last ? '' : ',' %]</code>:</p>

<pre><code class="sql Use the loop variable">[% FOREACH col IN column -%]
    [% col %] TEXT NOT NULL[% loop.last ? '' : ',' %]
[% END -%]
</code></pre>

<p>Now the comma will be omitted for the last iteration of the loop. The fix for
the verify script is even simpler: use <code>join()</code> <a href="http://tt2.org/docs/manual/VMethods.html" title="Template Toolkit Docs: Virtual Methods">VMethod</a> instead of a
<code>FOREACH</code> loop to emit all the columns in a single expression:</p>

<pre><code class="sql Join verify columns">SELECT [% column.join(', ') %]
  FROM [% IF table %][% table %][% ELSE %][% change %][% END %];
</code></pre>

<p>Really simplifies things, doesn&rsquo;t it?</p>

<p>Better still, going back to the deploy template, we can add data types for
each column. Try this on for size:</p>

<pre><code class="sh Deploy with typed columns">[% FOREACH col IN column -%]
    [% col %] [% type.item( loop.index ) or 'TEXT' %] NOT NULL[% loop.last ? '' : ',' %]
[% END -%]
);
</code></pre>

<p>As we iterate over the list of columns, simply pass <code>loop.index</code> to the
<code>item()</code> <a href="http://tt2.org/docs/manual/VMethods.html" title="Template Toolkit Docs: Virtual Methods">VMethod</a> on the <code>type</code> variable to get the corresponding type.
Then specify a type for each column when you create the change:</p>

<pre><code class="sh Create table with typed columns">&gt; sqitch add corp_widgets --template createtable \
  -s schema=corp -s table=widgets \
  -s column=id -s type=SERIAL \
  -s column=name -s type=TEXT \
  -s column=quantity -s type=INTEGER \
  -n 'Add corp.widgets table.'
</code></pre>

<p>This yields a much more comprehensive deploy script:</p>

<pre><code class="sql Deploy table with typed columns">-- Deploy corp_widgets

BEGIN;

SET search_path TO corp,public;

CREATE TABLE widgets (
    id SERIAL NOT NULL,
    name TEXT NOT NULL,
    quantity INTEGER NOT NULL
);

COMMIT;
</code></pre>

<h2>Go Crazy</h2>

<p>The basics for creating task-specific change templates are baked into Sqitch,
and a transparent upgrade to advanced templating is a simple install away. I
can imagine lots of uses for task-specific changes, including:</p>

<ul>
<li>Adding schemas, users, procedures, and views</li>
<li>Modifying tables to add columns, constraints and indexes</li>
<li>Inserting or Updating data</li>
</ul>


<p>Maybe folks will even start sharing templates! You should subscribe to the
<a href="https://groups.google.com/forum/#!forum/sqitch-users">mail list</a> to find out. See you there?</p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Data Deployment with Sqitch]]></title>
<link href="http://theory.so/sqitch/data/2013/08/28/data-deployment-with-sqitch/"/>
<updated>2013-08-28T17:09:00-07:00</updated>
<id>http://theory.so/sqitch/data/2013/08/28/data-deployment-with-sqitch</id>

      <content type="html"><![CDATA[<p>I&rsquo;ve been thinking about data migrations. I love how well <a href="http://sqitch.org/">Sqitch</a> works for
<em>schema</em> changes, but so far have avoided <em>data</em> changes. Some data ought to
be managed by the deployment process, rather than by end-user applications.
Lists of countries, for example. Yet none of <a href="http://iovation.com/">our</a> Sqitch-managed databases
include <code>INSERT</code>s, <code>UPDATE</code>s, or <code>DELETE</code>s in deploy scripts. Why not? Two
reasons:</p>

<ol>
<li><p>These are mainly Postgres ports of existing Oracle databases. As such, I&rsquo;ve
written independent migration scripts that use <a href="http://pgxn.org/extension/oracle_fdw"><code>oracle_fdw</code></a> to copy data
from Oracle. It made no sense to commit hard-coded changes to the deploy
script, even for static data, as it was all to be copied from the old
production Oracle databases &mdash; often months after I wrote the migrations.</p></li>
<li><p>These projects include extensive <a href="http://pgtap.org/">pgTAP</a> unit tests that expect to run many
times against an empty database with no side effects. Having different data
in testing than in production increases the likelihood of unforeseen
behavioral variations. Better to expect <em>no</em> data in tests, freeing them to
focus on units of behavior without regard to preexisting data.</p></li>
</ol>


<p>Now that we have multiple Sqitch-deployed databases in production, the time
has come to address these issues.</p>

<h2>Deploy Hooks for External Sources</h2>

<p>I propose to resolve the one-time migration requirement with <a href="https://github.com/theory/sqitch/issues/96">deploy hooks</a>.
The idea is similar to <a href="http://git-scm.com/docs/githooks">Git hooks</a>: Before or after any <code>sqitch deploy</code>, one
or more hook scripts can run. The impetus was to ensure some higher level of
consistency after every <code>deploy</code>. For example, a post-deploy hook might grant
privileges on all tables in a database. Another might run <code>VACCUM; ANALZYE;</code>.</p>

<p>But we could also use it for one-time data migrations. An option to <code>deploy</code>
will disable them, which would be useful for development and test databases.
Once the migration has been run in production, we just delete the migration
hook scripts from the project. Sqitch won&rsquo;t record hook executions, so adding
or removing them will be no problem.</p>

<p>I like this approach, as Sqitch will automatically run migration scripts, but
hooks will not change the interface of Sqitch itself. And it&rsquo;s more generally
useful. Hell, I might want deploy hook script that sends an email notification
announcing a deployment (though that might require adding support for
<a href="https://github.com/theory/sqitch/issues/1">non-SQL scripts</a>). There are all kinds of things for which hooks will prove
useful.</p>

<h2>Changes for Static Data Maintenance</h2>

<p>For data that must be tied to the deployment process, there are two
complications that have prevetned me from simply managing them in normal
Sqitch changes:</p>

<ol>
<li><p>There might be side-effects to the deployment. For example, a foreign key
constraint to the <code>users</code> table, to identify the users who added rows to
the database. But in a new database, perhaps there are no users &mdash; and
Sqitch doesn&rsquo;t create them, the app does. Chicken, meet egg.</p></li>
<li><p>The initial data set might derived from some external source, such as
another database. Consequently, none of that data was defined in Sqitch
deploy scripts. This situation complicates future updates of the data. We
can add data via Sqitch in the future, but then we don&rsquo;t have the canonical
list of all rows that should exist in all such databases.</p></li>
</ol>


<p>However, I can think of no alternative that does not over-complicate Sqitch
itself. I considered adding another change-related script type, named
&ldquo;update&rdquo;, to complement the existing deploy, verify, and revert scripts. But
oftentimes a data change would not be tied to a schema change, so the
corresponding deploy script would be a no-op. Seems silly.</p>

<p>I also considered adding a completely separate command specifically for
deploying data changes. Yet these data migrations are exactly like schema
changes: Sqitch must execute them in the proper order relative to other
changes, record successful or failed deployment, and be able to revert them
when required. The only difference is what&rsquo;s defined in them: data
modification rather than definition.</p>

<p>Through several drafts of this post, I have come around to the idea that I
should change nothing in Sqitch with regard to data deployments. A better
solution than the above, I believe, is organizational.</p>

<h3>Data Deploy Best Practice</h3>

<p>Let the best practice for data deploys be this: they should be contained in
Sqitch changes, but such changes should contain <em>only</em> data modifications. No
change script should both define a table and insert its initial rows. Keep the
table and its data in separate changes &mdash; keep DML separate from DDL.</p>

<p>For our list of countries, we might have a change named &ldquo;countries&rdquo;, which
creates the <code>countries</code> table, and another, named &ldquo;country_data&rdquo;, which
inserts the appropriate data into that table. Where necessary and appropriate,
these changes may use conditional paths to bring the data up-to-date and in
sync across deployments.</p>

<p>Conditions must deal with side-effects, such as foreign key constraints. Where
possible, such side effects ought be removed from deployment-managed data. For
tracking the user or users who added data to a database, for example, one can
use the tools of the source code repository (<code>git log</code>, <code>git blame</code>) to assign
blame. Other side-effects may be more necessary, but to the extent possible,
deployed data should be independent.</p>

<p>Naturally, unit tests must expect static data to be present, and be updated
when that data changes. We are, after all, talking about infrequently-updated
data. Frequently-updated data should have separate interfaces provided by
applications to change the data. Otherwise, how static is it, really?</p>
]]></content>
    </entry>
  
</feed>

