<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[theory.so]]></title>
  <link href="http://theory.so/atom.xml" rel="self"/>
  <link href="http://theory.so/"/>
  <updated>2013-08-28T16:46:55-07:00</updated>
  <id>http://theory.so/</id>
  <author>
    <name><![CDATA[David E. Wheeler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
    <entry>
      




<title type="html"><![CDATA[Data Deployment with Sqitch]]></title>
<link href="http://theory.so/sqitch/data/2013/08/27/data-deployment-with-sqitch/"/>
<updated>2013-08-27T11:38:00-07:00</updated>
<id>http://theory.so/sqitch/data/2013/08/27/data-deployment-with-sqitch</id>

      <content type="html"><![CDATA[<p>I&rsquo;ve been thinking about data migrations. I love how well <a href="http://sqitch.org/">Sqitch</a> works for
<em>schema</em> changes, but so far have avoided <em>data</em> changes. Some data ought to
be managed by the deployment process, rather than by end-user applications.
Lists of countries, for example. Yet none of <a href="http://iovation.com/">our</a> Sqitch-managed databases
include <code>INSERT</code>s, <code>UPDATE</code>s, or <code>DELETE</code>s in deploy scripts. Why not? Two
reasons:</p>

<ol>
<li><p>These are mainly Postgres ports of existing Oracle databases. As such, I&rsquo;ve
written independent migration scripts that use <a href="http://pgxn.org/extension/oracle_fdw"><code>oracle_fdw</code></a> to copy data
from Oracle. It made no sense to commit hard-coded changes to the deploy
script, even for static data, as it was all to be copied from the old
production Oracle databases &ndash; often months after I wrote the migrations.</p></li>
<li><p>These projects include extensive <a href="http://pgtap.org/">pgTAP</a> unit tests. These tests expect to
run many times against an empty database with no side effects. Having the
different data in testing than in production increases the likelihood of
unfortunate and unforeseen behavioral variations. Better to expect <em>no</em>
data in unit tests, to free to focus on units of behavior without regard to
preexisting data.</p></li>
</ol>


<p>Now that we have multiple Sqitch-deployed databases in production, the time
has come to address these issues.</p>

<h2>Deploy Hooks for External Sources</h2>

<p>I propose to resolve the one-time migration requirement with <a href="https://github.com/theory/sqitch/issues/96">deploy hooks</a>.
The idea is similar to <a href="xxx" title="githooks">Git hooks</a>: Before or after any <code>sqitch deploy</code>, one
or more hook scripts can be run. The original idea was to allow a script to be
run after every <code>deploy</code> to ensure some higher level of consistency. For
example, a post-deploy hook might grant privileges on all tables in a
database. Another might run <code>VACCUM; ANALZYE;</code> after every deploy.</p>

<p>But we could also use it for one-time data migrations. An option to <code>deploy</code>
will disable them, which would be useful for development and test databases.
Once the migration has been run in production, we just delete the migration
hook scripts from the project. Sqitch won&rsquo;t record hook executions, so adding
or removing them will be no problem.</p>

<p>I like this approach, as Sqitch will automatically run migration scripts, but
hooks will not change the interface of Sqitch itself. And it&rsquo;s more generally
useful. Hell, I might want a deploy hook script that sends an email
notification announcing a deployment (though that might require adding support
for <a href="xxx">non-SQL scripts</a>). There are all kinds of things for which hooks will
prove useful.</p>

<h2>Changes for Static Data Maintenance</h2>

<p>For data that must be tied to the deployment process, there are two
complications to simply managing them in normal Sqitch changes:</p>

<ol>
<li><p>There might be side-effects to the deployment. For example, a foreign key
constraint to the <code>users</code> table, to identify the users who added rows to
the database. But in a new database, perhaps there are no users &ndash; and
Sqitch doesn&rsquo;t create them, the app does. Chicken, meet egg.</p></li>
<li><p>The initial data set might be provided by some external source, such as a
deploy hook migration from another database. Consequently, none of that
data was defined in Sqitch deploy scripts. This situation complicates
future updates of the data. We can add data via Sqitch in the future, but
then we don&rsquo;t have the canonical list of all rows that should exist in all
such databases.</p></li>
</ol>


<p>However, I can think of no alternative that does not complicate Sqitch. I
considered adding another change-related script type, named &ldquo;update&rdquo;, to
complement the existing deploy, verify, and revert scripts. But oftentimes a
data change would not be tied to a schema change, so the corresponding
deploy script would  be a no-op. Seems silly.</p>

<p>I also considered adding a completely separate command specifically for
deploying data changes. Yet these data migrations are exactly like schema
changes: Sqitch must execute them in the proper order relative to other
changes, record successful or failed deployment, and be able to revert them
when required. The only difference is what&rsquo;s defined in them: data
modification rather than definition.</p>

<p>Through several drafts of this post, I have come around to the idea that I
should change nothing in Sqitch with regard to data deployments. A better
solution than the above, I believe, is organizational.</p>

<p>Let the best practice for data deployments be this: they should be contained
in q Sqitch changes, but such changes should contain <em>only</em> data
modifications. No change script should both define a table and its initial
rows. Keep the table and its data in separate changes &ndash; keep DML separate
from DDL.</p>

<p>For our list of countries, we might have a change named &ldquo;countries&rdquo;, which
creates the <code>countries</code> table, and another, named &ldquo;country_data&rdquo;, which
inserts the appropriate data into that table. Where necessary and appropriate,
these changes may use conditional paths to bring the data up-to-date and in
sync across deployments.</p>

<p>Conditions must deal with side-effects, such as foreign key constraints. Where
possible, such side effects should be removed from deployment-managed data.
For tracking the user or users who added data to a database, for example, one
can use the tools of the source code repository (<code>git log</code>, <code>git blame</code>)
toassign blame. Other side-effects may be more necessary, but to the extent
possible, deployed data should be as independent as possible.</p>

<p>Naturally, unit tests must expect the data to be present, and be updated when
that data changes. We are, after all, talking about infrequently-updated data.
Frequently-updated data should have separate interfaces provided by
applications to change the data. Otherwise, how static is it, really?</p>
]]></content>
    </entry>
  
</feed>
